# 设计模式之美
    
## 02 从那些纬度评判代码的好坏
        
        1、可维护性：在不破坏原有代码设计、不引入新的被bug的情况下，能够快速的修改或者添加代码。  
                   如果bug容易修复、修改、添加功能能够轻松完成，主管认为代码易维护。
    
        2、可读性：
            代码的可读性应该是评价代码质量最重要的指标之一。
            代码是否符合编码规范、命名是否达意、注释是否详尽、函数长短是否合适、模块划分是否清晰、是否符合高内聚低耦合等等。
    
        3、可扩展性：
            代码预留了一些功能扩展点、可以把新功能代码，直接插到扩展点上。对修改关闭、对扩展开放。
    
        4、灵活性：代码易扩展、易复用、或者易用。
    
        5、简洁性：代码简单、逻辑清晰
        
        6、可复用性：
        
        7、可测试性：
    
        如何写出高质量对代码：
            1.面向对象设计思想，继承、多态能让我们写出可复用的代码； 
            2.编码规范能让我们写出可读性好的代码； 
            3.设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可读性好、易扩展、易维护的代码； 
            4.设计模式可以让我们写出易扩展的代码； 
            5.持续重构可以时刻保持代码的可维护性等
            
## 03 面向对象、设计原则、设计模式、编程规范、重构
    
        1、面向对象:
            面向对象编程、面向过程编程、函数式编程。
            面向对象编程具有丰富的特性、实现复杂设计思路、设计原则、设计模式的基础。 
            面向对象四大特性:封装、抽象、继承、多态。
           
        2、设计原则:
            设计原则是代码设计的一下经验总结。
    
        3、设计模式:
            设计模式是针对软件开发中经常遇到对一些设计问题，总结出来对一套解决方案或者设计思路。
            大部分设计模式解决对问题都是代码对可扩展性问题。
                    
            创建型：
                常用：单例模式、工厂模式、创建者模式
                不常用：原型模式
            
            结构型：
                常用：代理模式、桥接模式、装饰者模式、适配器模式
                不常用：门面模式、组合模式、亨元模式
            
            行为型：
                常用：观察者模式、模板模式、策略模式、责任链模式、迭代器模式、状态模式
                不常用：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。
    
        4、编程规范:
            主要解决对是代码对可读性问题。更注重代码细节。
        
        5、代码重构:
            代码重构对工具就是哪里面向对象设计思想、设计原则、设计模式、编码规范。
            设计思想、设计原则、设计模式一个最重要对应用场景就是重构。
            
## 04 理论一：当谈论面向对象的时候，到底在谈论什么
        
        面向对象编程OOP:是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性代码设计和实现的基石。
        
        面向对象编程语言:是支持类或对象的语法机制，并有现成的语法机制，能方便实现面向对象编程四个特性的编程语言。
        
        面向对象分析OOA: 围绕对象或类来做需求分析。 程序被拆解为哪些类、每个类有哪些属性、类与类之间的关系。
        
        面向对象设计OOD: 围绕对象或类来做需求色设计。
        
##05 理论二：封装、抽象、继承、多态分别可以解决那些编程问题
    
        1、封装：也叫信息隐藏或数据访问包含。授权外部仅能通过类提供的方式来访问内部信息或者数据。
            对于封装这个特性，需要编程语言本身提供一定的语法机制来支持，这个语法机制就是访问权限控制。
    
            如果对类中对属性访问不做限制，那么代码可以访问、修改类中对属性，看起来更灵活，但是灵活也意味着不可控。
            修改逻辑可能散落中代码中对各个角落，势必影响代码对可读性、可维护性。
    
            类仅仅通过有限对方法暴露必要对操作，也能提供易用性。
    
        2、抽象：
    
            封装主要讲对是如何隐藏信息、保护数据，抽象讲的是如何隐藏方法的具体实现。
            让调用者只需要关心方法提供了那些功能，并不需要知道这些功能如何实现的。
    
            interface关键字、abstract 关键字两种语法机制来实现抽象特性。
    
            "函数"非常基础的语法机制、就可以实现抽象特性。所以抽象没有特异性，有时候不被看作面向对象编程的特性之一。
            抽象作为一种关注功能点不关注实现的设计思路。
    
        3、继承:
            继承是用来表示之间的 is-a关系。
            继承最大的一个好处就是代码复用。
            过度的使用继承，继承层次过深过复杂，就好导致代码的可读性，可维护性变差。
            
        4、多态：
            多态是指，子类可以替换父类。在代码运行时，调用子类的方法实现。
            
            用到三个语法机制来实现多态：
                a、父类对象可以引用子类对象。
                b、要支持继承。
                c、支持子类可以重写父类中的方法。  
                
            Java 这样的静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口。
            
            多态特性能提供代码的可扩展性和复用性。
            多态是很多设计模式、设计原则、编程技巧的代码实现基础。
            
            
## 06 面向对象比面向过程有哪些优势，面向过程过时了吗       
    
        1、面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基础。
           
           面向过程编程是一种编程范式或编程风格。它以过程(方法、函数)作为组织代码的基本单元，以数据与方法相分离为最主要的特点。
           面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。
           
           面向编程语言首先是一种编程语言，他的最大特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性，仅支持面向过程编程。
           
            面向过程和面向对象最基本的区别就是：代码的组织方式不同。
            面向过程风格的代码被组织成了一组方法集合及其数据结构,方法和数据的定义是分开的。
            面向对象风格的代码被组织成一组类，方法和数据机构被绑定一起，定义在类中。
    
        2、面向对象编程的优势：
    
            OOP 更加能应对大规模复杂程序的开发。
    
            面向对象编程是以类为思考对象。在进行面向对象编程的时候，我们并不是一上来就去思考，
            如何将复杂的流程拆解为一个个方法，而是采用曲线救国的策略，先去思考如何给业务建模，
            如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。
            当有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。
            这种开发、思考问题的方法，能让我们应对复杂程序开发的时候，思路更加清晰。
            类是一种非常好的组织函数和数据结构的方式，是将代码模块化的有效手段。
    
            OOP 风格的代码更易复用、易扩展、易维护
    
            OOP 语言更加人性化、更加高级、更加智能
                汇编语言 ----> 面向过程语言 ---> 面向对象语言
    
    
## 07 那些代码设计看似是面向对象，实际是面向过程的
    
        1、滥用 getter、setter 方法：
            它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程的编程风格。

        2、滥用全局变量和全局方法
            静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。

            影响代码可维护性
            增加代码编译时间：Constants 类中的很多常量定义的时候，依赖这个类的代码很多。 
                            那么每次修改Constants 类，都会导致它的类文件重新编译。
            影响代码的复用性：复用项目开发的某个类，而这个类又依赖 Constants 类。

            如何改进 Constants 类设计：
            第一种：将Constants类拆解为功能更加单一的多个类。
            第二种：不单独的设计Constants 常量类，而是哪个类用到类某个常量，就把常量定义在这个类中。

        3、定义数据和方法分离的类
            
            传统的 MVC 结构就是典型的面向过程的编程风格。
            这种开放模式叫做基于贫血模式的开放模式，也是一种 web项目开发模式。

        4、面向对象编程中，为什么容易写出面向过程的代码：
            面向过程编程风格恰恰符合人的这种流程化思维方式。面向对象编程风格正好相反。它是一个自底向上的思考方式。
            不按照流程来分解任务，而是将任务翻译成一个一个小的模块（类），数据类之间的交互，最后按照流程将类组装起来，
            完成整个任务。


## 08 接口 vs 抽象的区别，如何用普通的类模拟抽象类和接口

    接口和抽象类的区别、什么时候用接口、什么时候用抽象类，抽象类和接口存在的意义是什么，能解决那些问题？
    
    抽象类具体特点：
        1、抽象类不允许被实例化，只能继承。
        2、抽象类可以保护属性和方法
        3、子类继承抽象类，必须实现抽象类中的所有抽象方法。
        
    接口特点：
        1、接口不能包含属性（也就是成员变量）
        2、接口只能声明方法，方法不能包含代码实现
        3、类实现接口的时候，必须实现接口中声明的所有方法

    抽象类是为代码复用而生的。与普通的类区别中于必须让子类实现抽象方法。
    抽象类是为类代码复用，而接口更侧重于解耦合。接口是对行为对一种抽象，相当于一组协议或者契约。

    如何决定该有抽象类还是接口？
        实际上，如果表示一种 is-a 的关系，并且是为类解决代码复用的问题，我们就用抽象类。
        如果表示一种 has-a 关系，并且是为类解决抽象而非代码复用的问题，就用接口。

        抽象类是一种自下而上的设计思路，现有子类的代码重复，然后再抽象成上层父类。
        接口正好相反，它是一种自上而下的设计思路。


## 09 为什么基于接口而非实现编程，有必要为每个类都定义接口吗？        

    编写代码都时候，要遵从"基于接口而非实现编程"的原则，需要做到3点：
        1、函数的命名不能暴露任何实现细节。
        2、封装具体的实现细节。
        3、为实现类定义抽象的接口。具体实现类都依赖统一都接口定义。

    
    接口和实现相分离，封装不稳定都实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节。
    如果，某个功能只有一种实现方法，未来也不可能被其他实现方式替换，就没有必要设计接口。


## 10 继承还是组合？
    
    类的继承层次越深、继承关系约复杂。一方面导致代码的可读性变差。要搞清楚某个类具有哪些方法、属性，必须阅读父类代码
    父类的父类代码。另一方面，也破坏类类的封装特性，将父类的实现细节暴露给了子类。
    子类的实现依赖父类的实现，两者高度耦合，一定父类修改，影响所有子类。

    利用 组合、接口、委托 三个技术手段一块解决继承存在的问题。
    
    接口表示具有某种行为特性。接口只声明方法，不定义实现。如果每个类都实现接口，导致代码重复。
    我们可以针对接口定义一个实现类，通过组合和委托都技术来消除代码实现。

    
    继承都三个作用：表示 is-a 关系、支持多态性、代码复用。
    通过组合和接口都 has-a 关系替代 is-a 关系
    多态特性可以用接口来实现。
    代码复用可以通过组合和委托来实现。

    继承改写组合意味着要做更细的粒度类的拆分。定义更多的接口和类。
    类和接口的增加也就或多或少增加代码的复杂度和维护成本。

    如果继承机构稳定，继承层次比较浅，继承关系不复杂，我们就大胆使用继承。
    反之，系统不稳定、继承层次很深、继承关系复杂、就用组合代替继承。

    
## 11 业务开发常用的基于贫血模型的 MVC 架构违背 OOP 吗？
    
    贫血模式：Service 层的数据和业务逻辑，被分割为BO 和 Service 两个类中。
    只包含数据，不包含业务逻辑的类，叫做贫血模型。贫血模型将数据和操作分离，
    破坏了面向对象的封装特性。

    充血模型：数据和对应的业务逻辑被封装到同一个类中，充血模型满足面向对象的封装特性。

    大部分都是SQL驱动(SQL-Driven)开发模式。我们接到一个后端接口的开发需求的时候，
    就去看需要的数据对应到数据库中，需要那张表或那几张表，然后思考如何编写 SQL 语句
    来获取数据。之后就是定义 Entity、BO、VO，然后模板式的王对应的 Repository、Service、Controller 
    类中添加代码。业务逻辑包裹在一个大的SQL语句中，而service层可以做的事情很少。
    SQL 都是针对特定的业务功能编写的，复用性差。当开发另一个业务时，只能重写满足需求的SQL语句。
    导致各种长得差不多、区别很小的 SQL 语句漫天飞。

    
## 12 DDD模型开发虚拟钱包系统

    DDD开发模式，跟基于贫血模型的开发模式主要区别在 Service 层，Controller、Repository 层
    的代码基本相同。设计一个充血的 Domain 领域模型，让原来的 Service 类中的部分业务逻移到这个类中，
    让 Service 类的实现依赖这个类。

    DDD开发模式中，service 类变的很薄，service 在这种情况下职责是什么？那些逻辑放在service中。
    区别于 Domain 的职责，Service 类主要有下面这样的职责。
    
        1、Service 类负责与 Repository 交流。调用Repository类方法，获取数据库的数据，转化成领域模型类
            然后由领域模型类来完成业务逻辑。最后调用Repository类的方法，将数据写回数据库。
    
            我们让 Service 类与Repository打交道，而不是让领域模型类与Repository打交道，保持领域模型
            的独立行，不与任何其他层代码或开发框架耦合在一起，将流程行代码逻辑与领域模型的业务逻辑解耦，
            让领域模型更加可复用。
    
        2、Service 类负责跨领域模型的业务聚合功能。
            两个领域模型的交互可以放在service 中，或者设计成一个独立的领域模型。
    
        3、Service 类负责一些非功能行与第三方系统交互的工作。比如：幂等、发邮件、发消息、记录日志、
            调用其他系统的 RPC 接口等等。

    在基于充血模型的 DDD 开发模式中，尽管 Service 层被改造成了充血模型，但是 Controller 层和 
    Repository 层还是贫血模型，是否有必要也进行充血领域建模呢？
        没有必要。Controller 层主要负责接口的暴露，Repository 层主要负责与数据库打交道，
        这两层包含的业务逻辑并不多，前面我们也提到了，如果业务逻辑比较简单，就没必要做充血建模，
        即便设计成充血模型，类也非常单薄，看起来也很奇怪。

        Repository 的 Entity 来说，即便它被设计成贫血模型，违反面向对象编程的封装特性，
        有被任意代码修改数据的风险，但 Entity 的生命周期是有限的。
        一般来讲，我们把它传递到 Service 层之后，就会转化成 BO 或者 Domain 来继续后面的业务逻辑。
        Entity 的生命周期到此就结束了，所以也并不会被到处任意修改。

        Controller 层的 VO。实际上 VO 是一种 DTO（Data Transfer Object，数据传输对象）。
        它主要是作为接口的数据传输承载体，将数据发送给其他系统。
        从功能上来讲，它理应不包含业务逻辑、只包含数据。所以，我们将它设计成贫血模型也是比较合理的。
        
    
## 13 面向对象设计（OOD） 

    针对面向对象分析，如何进行面向对象设计、面向对象编程。
        面向对象分析产出的是详细的需求描述。
        面向对象设计的产出是类。
         
    如何进行面向对象设计:
        将需求描述转化为具体的类设计，主要包含以下几部分:
            1、划分职责进而识别出有哪些类。
            2、定义类以及其属性和方法。
            3、定义类与类之间的交互关系。
            4、将类组织起来并提供执行入口。
    
    1、划分职责进而识别出有哪些类：
        类是现实世界事物的一个建模。但是并不是每个需求都能映射到现实世界。
        根据需求描述，把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，是否应该归为一类。
        拆解出来的每个功能要尽可能的小。每个功能点只负责做一件很小的事情（单一职责）。
        
        针对复杂的需求开发，首先进行模块划分、将需求先简单划分成几个小的、独立的功能模块，然后再在模块内部，
        罗列功能点，进行面向对象设计。模块的划分和识别、跟类的划分和识别，是类似的。
        
    2、定义类及其属性和方法：
        
        根据职责拆分的类。对每个类从功能点列表中挖掘属性和方法。
        对方法的识别，一般都是识别出需求描述中的动词作为候选方法，再进一步筛选。
        功能点中的名词，作为候选属性，然后进行过滤筛选。
        
        注意：
            第一个细节:并不是所有出现的名词都被定义为类的属性，有些需要作为方法的参数。
            第二个细节:需要挖掘一下没有出现的功能点描述中属性， 比如createTime 等。
                   
    3、类之间的关系：
        泛化、实现、组合、依赖
        
    4、将类组装起来并提供执行入口:
        这个入口可能是一个main()函数，也可能是一组给外部用的 API 接口。通过这个接口，触发代码跑起来。
        
    如何进行面向对象编程：
        面向对象编程的工作，就是将这些设计思路翻译成代码实现。        
        
## 15 单一职责原则
    
    SOLID 原则，不是单纯的1个原则，由5个设计原则组成: 单一职责原则、开闭原则、里氏替换原则、接口隔离原则、依赖反转原则。
    
    单一职责原则: Single Responsibility Principle， A Class or module should have a single responsibility。
    一个类或模块只负责完成一个之职责（或功能）。
    不要设计大而全的类，设计粒度小、功能单一的类。
    
    先写一个粗粒度的类、满足业务需求。随着业务的发展、如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以讲这个粗粒度
    的类，拆分成几个更细粒度的类，这就是重构。
 
## 16 开闭原则
    
    开闭原则：软件实体（模块、类、方法）应该“对扩展开发、对修改关闭”。
    添加一个新的功能应该是，在已有代码基础上扩展代码(新增模块、类、方法)，而非修改已有代码(修改模块、类、方法)。
    
    
    
    


## 17 里式替换原则：

    子类对象能够替换程序中父类对象出现对任何地方，并且保证原来程序对逻辑行为不变及正确性不被破坏。
    
    多态和里式替换有点类似，但关注点不一样。多态是面向对象编程但一大特性，也是面向对象编程语言但一种语法。
    它是代码实现但思路。而里式替换式一种设计原则，是用来指导继承关系中子类该如何设计但，子类的设计要保证
    中替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。

    子类设计的时候，要遵循福利的行为约定，福利定义类函数的行为规范，那么子类可以改变函数的内部实现逻辑，
    但不能改变函数原有但行为约定。这里的行为约定包括：函数声明的功能实现、对输入、输出、异常对约定等等。


## 18 接口隔离原则：

    接口隔离原则：客户端不应该被强迫依赖它不需要对接口。
    
    "接口" 可以理解为三种东西：
        一组 API 接口集合：
            如果部分接口只被部分调用者使用，那么需要将这部分接口隔离出来，单独给对应对调用者使用，
            而不是强迫其他调用者也依赖者部分不被调用对接口。
        单一 API 接口或函数：
            函数功能设计要单一，不要将多个不同的功能逻辑在一个函数中实现。

            单一职责原则针对的是模块、类、接口设计。而接口隔离原则相对于单一职责原则，一方面它更
            侧重于接口的的设计，另一方面它的思考角度不同。它提供类一种判断接口是否职责单一的标准：
            通过调用者如何使用接口来间接的判定，如果调用者使用部分接口或接口的部分功能，那接口的设计就不够职责单一。

        OOP 中对接口概念：


## 19 控制反转、依赖反转、依赖注入 三者有和区别和联系
    
    依赖反转原则: (用起来比较简单、但概念理解起来比较困难)
    “依赖反转”这个概念指的是“谁跟谁”的“什么依赖”被反转了？“反转”两字改如何理解？
    “控制反转” 和 “依赖注入” 这两个概念跟 “依赖反转”有什么区别和联系。
    
    1、控制反转(IOC):
        Inversion Of Control, 缩写 IOC。
        
        框架提供了一个可扩展的代码骨架，用来组装对象，管理整个执行流程。程序员利用框架进行开发的时候，
        只需要往预留的扩展点上，添加跟自己相关的代码，就可以利用框架来驱动整个程序流程的执行。
        
        这里 “控制” 指的是对程序执行流程的控制，而 “反转” 指的是在没看框架之前，程序自己控制整个程序的执行。
        在使用框架之后，整个的控制流程可以通过框架来控制，流程的控制权从程序员“反转”到了框架。
        
        控制反转不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层的设计。
        
    
    2、依赖注入(DI):
        
        依赖注入跟控制反转恰恰相反，它是一种具体的编码技巧。
        不是通过new()的方式在类内部创建依赖对象，而是将依赖的类对象在外部创建好，通过构造函数，函数参数等方式传递(注入)给类使用。        
        通过依赖注入的方式将依赖的类对象传递进来，这样就提供了代码的扩展性，可以灵活的替换依赖的类。基于接口而非实现编程。

    3、依赖注入框架：
        
        在实际的开发中，项目会涉及到成百上千个类，类对象的创建和依赖注入会变得非常复杂。
        而对象创建和依赖注入工作，本身和业务无关，完全可以抽象成框架来自动完成。

        我们可以通过依赖注入框架提供的扩展点，简单配置一下所需要的类，类与类直接的依赖关系，就可以实现框架来自动创建对象。
        管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

        Spring 框架声称自己是控制反转容器。
        控制反转容器这种表述是一种非常宽泛的描述，DI依赖注入框架的表述更具体、更有针对性。
        Spring 框架的控制反转主要通过依赖注入来实现的。

    4、依赖反转原则：（依赖倒置原则）
        高层模块不要依赖底层模块。高层模块和底层模块应该通过抽象来互相依赖。抽象不要依赖具体实现细节，
        具体实现细节依赖抽象。

        高层模块和底层模块，简单来说，在调用链上，调用者属于高层、被调用者属于底层。


        
    
         
    
        
        
             
        
        
                        
            
            
            
        
        
        
        

    


    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
                    
        
        